# Qwen Code Guidelines for Naver Search Engine Project

## Project Context
This is a Naver Search Engine frontend application built with React Router v7, TypeScript, and TailwindCSS. It integrates with Naver Search API and includes features for blog search, news search, and scraping Naver's popular posts section.

## Project Structure (FSD Architecture)
- `app/constants/` - Constants (headers, selectors, blog-ids)
- `app/entities/` - Domain entities
- `app/features/` - Feature modules (FSD architecture)
  - `naver-popular/` - Main popular search feature
  - `search/` - Search functionality
  - `doc/` - Document analysis features
- `app/routes/` - API and page routes
- `app/shared/` - Shared utilities and components

## Core Technologies
- React 19 + React Router v7 (with SSR)
- TypeScript (strict mode)
- TailwindCSS v4
- Jotai for state management
- Vite for build tooling
- Cheerio for HTML parsing

## Development Commands
```
npm run dev          # Start development server (port 4001)
npm run build        # Create production build
npm run start        # Start production server
npm run typecheck    # Run type checking
```

## Environment Variables
```
NAVER_CLIENT_ID=your_client_id
NAVER_CLIENT_SECRET=your_client_secret
```

## Coding Conventions
1. Use absolute imports with `@/` prefix
2. Always use `React.Fragment` instead of `<>`
3. Use `cn()` utility for className management
4. Define TypeScript interfaces for all component props
5. Follow Jotai patterns for state management
6. Use TailwindCSS for styling with responsive patterns
7. Implement proper error handling

## Component Structure
```typescript
interface ComponentProps {
  // Define all props with types
}

export const ComponentName = ({ prop1, prop2 }: ComponentProps) => {
  return (
    <React.Fragment> {/* Use React.Fragment instead of <> */}
      {/* Component content */}
    </React.Fragment>
  );
};
```

## Naver HTML Parsing
The application scrapes Naver search results using Cheerio. When Naver changes their HTML structure, you may need to update CSS selectors. The current selectors for popular posts are:
- Container: `.fds-ugc-single-intention-item-list`
- Item: `.w0FkNRfc2K6rffX0LJFd`
- Title link: `.Pcw4FFPrGxhURyUmBGxh`
- Preview: `.XEJeYBY31zkS37HszIeB`

## Special Command: Naver Popular Selector Update
When Naver changes their HTML structure, and you're provided with updated HTML, follow this workflow:

### 1. HTML Analysis
Extract the following from the provided HTML:
- Popular posts list container class (e.g., `.fds-ugc-single-intention-item-list`)
- Each popular post item container class (e.g., `.Orf2UUyw2B80LaIjeSZl`)
- Title link class (e.g., `.M9lOyC5Ckpmk7fKVCMeD`)
- Preview text container class (e.g., `.FPXivxJt5AqSLccij6Pm`)
- Blog name class (`.sds-comps-profile-info-title-text`)
- Category header class (`.sds-comps-text-type-headline1`)

### 2. Current Code Review
Read `app/shared/utils/_popular.ts` to see currently used selectors

### 3. Selector Updates
Update the `readPopularSection` function in `_popular.ts`:
- Update item container selector
- Update title link selector
- Update preview selector
- Update HTML structure comments with the current date

### 4. Commit Format
When updating selectors, use this commit format:
```
fix: 네이버 인기글 파싱 셀렉터 업데이트 (YYYY-MM-DD)

네이버 HTML 구조 변경에 따른 셀렉터 업데이트:
- 아이템 컨테이너: .기존클래스 → .새클래스
- 제목 링크: .기존클래스 → .새클래스
- 미리보기: .기존클래스 → .새클래스
- HTML 구조 주석 업데이트
```

### 5. Filtering Rules
- Filter out cafe links (excluding `.includes('cafe.naver.com')`)
- Filter out ad links (excluding `.includes('ader.naver.com')`)
- Maintain existing logic while only updating class names

## File Permissions
The project allows various bash commands including:
- Git operations (add, commit, checkout, reset, restore, rm)
- NPM/Yarn commands (install, run typecheck, run build)
- General file operations (cat, tree, mv, xargs)
- Node/tsx execution for testing

## API Rate Limits
- Naver Search API has a limit of 25,000 calls per day
- Include proper error handling for API requests

## Architecture Principles
- Use FSD (Feature-Sliced Design) for organizing features
- Separate UI components, hooks, business logic, and state management
- Implement SSR with React Router v7
- Use Jotai atoms for state management with derived and action atoms